<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Calculadora</title>
</head>
<body>
    <h2>Calculadora de Cifras</h2>
    <label for="num1">N√∫mero inicial 1:</label>
    <input type="number" id="num1" value="2023"><br>

    <label for="num2">N√∫mero inicial 2:</label>
    <input type="number" id="num2" value="2024"><br>

    <label for="num3">N√∫mero inicial 3:</label>
    <input type="number" id="num3" value="2025"><br>

    <label for="numCifras">Cantidad de cifras:</label>
    <input type="number" id="numCifras" value="4"><br>

    <label for="posicion">Posici√≥n deseada:</label>
    <input type="number" id="posicion" value="2023202320232023"><br>

    <button onclick="calcular()">Calcular</button>
    
    <p id="resultado"></p>

    <script>
        function calcular() {
            // Se convierten los n√∫meros iniciales, num de cifras y posicion a BigInt para manejar grandes valores
            let nums = [
                BigInt(document.getElementById("num1").value),
                BigInt(document.getElementById("num2").value),
                BigInt(document.getElementById("num3").value)
            ];

            let numCifras = BigInt(document.getElementById("numCifras").value);
            let posicion = BigInt(document.getElementById("posicion").value);
            
            // Se verifica que la posici√≥n sea v√°lida
            if (posicion < 1n) {
                document.getElementById("resultado").innerText = "La posici√≥n debe ser 1 o mayor.";
                return;
            }

            // se define la variable modulus para limitar los n√∫meros a las cifras deseadas
            let modulus = BigInt(10) ** numCifras;

            // Se inicializa el array 'lastThree' con los tres n√∫meros iniciales
            let lastThree = [...nums];

            // Mapa para guardar patrones y su posici√≥n en la secuencia para detectar ciclos
            let seenPatterns = new Map();

            // Se inicia la posici√≥n actual en 3, ya que hay tres valores iniciales
            let currentPos = 3n;

            // Se limitan las iteraciones para evitar que se congele la pagina
            const maxIterations = 10_000_000n;

            // Se guarda el primer patr√≥n (los tres primeros n√∫meros) en el mapa
            seenPatterns.set(lastThree.toString(), currentPos);

            // Bucle que genera la secuencia hasta alcanzar la posici√≥n deseada o detectar un ciclo
            while (currentPos < posicion) {
                // Si se alcanzan las iteraciones m√°ximas, muestra un mensaje de error
                if (currentPos > maxIterations) {
                    document.getElementById("resultado").innerHTML = "Error ü§∑‚Äç‚ôÇÔ∏è Alcanzaste el l√≠mite de iteraciones.<br>Proba una posici√≥n o cantidad de cifras menor.";
                    return;
                }

                // Calcula el siguiente n√∫mero en la secuencia (suma de los √∫ltimos tres valores, limitado por 'modulus')
                let nextNum = (lastThree[0] + lastThree[1] + lastThree[2]) % modulus;

                // Actualiza 'lastThree' eliminando el primer valor y agregando el nuevo al final
                lastThree = [lastThree[1], lastThree[2], nextNum];
                currentPos++;

                // Convierte el nuevo patr√≥n de 'lastThree' a string para almacenarlo en el mapa
                let pattern = lastThree.toString();

                // Verifica si el patr√≥n ya se ha visto (indicando un ciclo)
                if (seenPatterns.has(pattern)) {
                    // Si hay ciclo, obtiene el inicio del ciclo y su longitud
                    let cycleStart = seenPatterns.get(pattern);
                    let cycleLength = currentPos - cycleStart;

                    // Calcula la posici√≥n dentro del ciclo correspondiente a la posici√≥n deseada
                    let positionInCycle = (posicion - cycleStart) % cycleLength;
                    let finalPosition = cycleStart + positionInCycle;

                    // Obtiene el valor en la posici√≥n final del ciclo desde el mapa
                    let resultadoCifras = Array.from(seenPatterns)[Number(finalPosition - 1n)][0];

                    // Divide el valor en caso de que haya comas y toma el √∫ltimo segmento
                    let partes = resultadoCifras.split(',');
                    let ultimoValor = partes[partes.length - 1];

                    // Si hay m√°s de una coma, concatena las partes para obtener el n√∫mero correcto
                    if (partes.length > 1) {
                        ultimoValor = partes[partes.length - 2] + ultimoValor;
                    }

                    // Muestra las √∫ltimas cifras en la posici√≥n deseada
                    document.getElementById("resultado").innerText = `Las √∫ltimas ${numCifras} cifras en la posici√≥n ${posicion} son: ${ultimoValor.slice(-Number(numCifras))}`;
                    return;
                } else {
                    // Si no se ha detectado un ciclo, guarda el patr√≥n actual en el mapa
                    seenPatterns.set(pattern, currentPos);
                }
            }

            // Si no se detecta ciclo y se alcanza la posici√≥n deseada, muestra el resultado final
            document.getElementById("resultado").innerText = `Las √∫ltimas ${numCifras} cifras en la posici√≥n ${posicion} son: ${lastThree[2].toString().slice(-Number(numCifras))}`;
        }
    </script>
</body>
</html>